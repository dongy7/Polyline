{"version":3,"file":"index.es.js","sources":["../src/utils.js","../src/index.js"],"sourcesContent":["// @flow\n\nexport type Coordinate = [number, number]\nexport type Line = Array<Coordinate>\nexport type DistFunc = (start: Coordinate, end: Coordinate) => number\nexport type Segment = {\n  start: Coordinate,\n  end: Coordinate,\n  mileDistance: number,\n  euclideanDistance: number,\n  percentCovered: number,\n  accumulatedPercentCovered: number,\n}\nexport type Polyline = {\n  segments: Array<Segment>,\n  euclideanLength: number,\n  mileLength: number,\n}\nexport type Searcher = (polyline: Polyline, percent: number) => Coordinate\n\n// kilometers per mile\nconst kiloPerMile = 1.60934\n\n// radius or earth in miles\nconst earthRadius = 3961\n\nexport const square = (x: number) => x * x\n\n// rounds to the nearest thousandth digit\nexport const round = (n: number) => Math.round(n * 1000) / 1000\n\nexport const getEuclideanDist: DistFunc = (a: Coordinate, b: Coordinate) => {\n  const squaredDistance = square(a[0] - b[0]) + square(a[1] - b[1])\n  return Math.sqrt(squaredDistance)\n}\n\nconst degreeToRad = (degree: number) => degree * (Math.PI / 180)\n\n// get the distance in miles between two coordinates\nexport const getMileDist: DistFunc = (start: Coordinate, end: Coordinate) => {\n  const startInRadians = start.map(degree => degreeToRad(degree))\n  const endInRadians = end.map(degree => degreeToRad(degree))\n  const [startLatitude, startLongitude] = startInRadians\n  const [endLatitude, endLongitude] = endInRadians\n\n  const latitudeDelta = endLatitude - startLatitude\n  const longitudeDelta = endLongitude - startLongitude\n  const a =\n    square(Math.sin(latitudeDelta / 2)) +\n    Math.cos(startLatitude) *\n      Math.cos(endLatitude) *\n      square(Math.sin(longitudeDelta / 2))\n  const c = Math.atan2(Math.sqrt(a), Math.sqrt(1 - a)) * 2\n  return round(earthRadius * c)\n}\n\nexport const milesToKm = (mile: number) => mile * kiloPerMile\n\nexport const buildPolyline = (geojson: Line): Polyline => {\n  if (geojson.length === 1) {\n    const [start] = geojson\n    return {\n      segments: [\n        {\n          start,\n          end: start,\n          mileDistance: 0,\n          euclideanDistance: 0,\n          percentCovered: 1,\n          accumulatedPercentCovered: 1,\n        },\n      ],\n      mileLength: 0,\n      euclideanLength: 0,\n    }\n  }\n\n  const polyline: Polyline = { mileLength: 0, euclideanLength: 0, segments: [] }\n\n  for (let i = 0; i < geojson.length - 1; i += 1) {\n    const start = geojson[i]\n    const end = geojson[i + 1]\n    const mileDist = getMileDist(start, end)\n    const euclideanDist = getEuclideanDist(start, end)\n\n    polyline.segments.push({\n      start,\n      end,\n      mileDistance: mileDist,\n      euclideanDistance: euclideanDist,\n      percentCovered: 0,\n      accumulatedPercentCovered: 0,\n    })\n\n    polyline.euclideanLength += euclideanDist\n    polyline.mileLength += mileDist\n  }\n\n  let distanceCovered = 0\n  polyline.segments.forEach((segment, index) => {\n    const { mileDistance } = segment\n    distanceCovered += mileDistance\n    polyline.segments[index].percentCovered = mileDistance / polyline.mileLength\n    polyline.segments[index].accumulatedPercentCovered =\n      distanceCovered / polyline.mileLength\n  })\n\n  return polyline\n}\n\nconst getInterpolatedPoint = (\n  segment: Segment,\n  segmentPercentage: number,\n  offset: number\n): Coordinate => {\n  const { start, end } = segment\n\n  const offsetProportion = offset / segmentPercentage\n\n  const [startLat, startLong] = start\n  const [endLat, endLong] = end\n  const deltaX = Math.abs(endLat - startLat) * offsetProportion\n  const deltaY = Math.abs(endLong - startLong) * offsetProportion\n\n  const offsetX = startLat < endLat ? deltaX : -deltaX\n  const offsetY = startLong < endLong ? deltaY : -deltaY\n\n  return [startLat + offsetX, startLong + offsetY]\n}\n\nexport const linearSearcher: Searcher = (\n  polyline: Polyline,\n  percent: number\n): Coordinate => {\n  const { segments, mileLength } = polyline\n\n  let segment = segments[segments.length - 1]\n  let percentRemaining = percent\n\n  for (let i = 0; i < segments.length; i += 1) {\n    const { percentCovered, accumulatedPercentCovered } = segments[i]\n    if (accumulatedPercentCovered >= percent) {\n      segment = segments[i]\n      break\n    }\n\n    percentRemaining -= percentCovered\n  }\n\n  return getInterpolatedPoint(\n    segment,\n    segment.mileDistance / mileLength,\n    percentRemaining\n  )\n}\n\nexport const binarySearcher: Searcher = (\n  polyline: Polyline,\n  percent: number\n): Coordinate => {\n  const { segments, mileLength } = polyline\n  let min = 0\n  let max = segments.length - 1\n  let segment = segments[max]\n\n  while (min !== max) {\n    const mid = Math.floor((min + max) / 2)\n    segment = segments[mid]\n\n    const { accumulatedPercentCovered } = segment\n    if (accumulatedPercentCovered < percent) {\n      min = mid + 1\n    } else {\n      max = mid\n    }\n  }\n\n  segment = segments[min]\n  const prevAccumulatedPercent =\n    max > 0 ? segments[max - 1].accumulatedPercentCovered : 0\n  const percentRemaining = percent - prevAccumulatedPercent\n\n  return getInterpolatedPoint(\n    segment,\n    segment.mileDistance / mileLength,\n    percentRemaining\n  )\n}\n","import type { Coordinate, Line } from './utils'\nimport { buildPolyline, milesToKm, getMileDist, binarySearcher } from './utils'\n\nexport class Polyline {\n  constructor(geojson: Line) {\n    this.line = geojson\n    this.polyline = buildPolyline(geojson)\n  }\n\n  getLengthInMiles() {\n    return this.polyline.mileLength\n  }\n\n  getLengthInKm() {\n    return milesToKm(this.getLengthInMiles())\n  }\n\n  getPointCovering(percent: number) {\n    return binarySearcher(this.polyline, percent)\n  }\n}\n\nconst createLine = (geojson: Line): Polyline => new Polyline(geojson)\n\nconst getDistanceBetweenPoints = (start: Coordinate, end: Coordinate) =>\n  getMileDist(start, end)\n\nconst getDistanceBetweenPointsKm = (start: Coordinate, end: Coordinate) =>\n  milesToKm(getDistanceBetweenPoints(start, end))\n\nexport default {\n  createLine,\n  getDistanceBetweenPoints,\n  getDistanceBetweenPointsKm,\n}\n"],"names":["kiloPerMile","earthRadius","square","x","round","n","Math","getEuclideanDist","a","b","squaredDistance","sqrt","degreeToRad","degree","PI","getMileDist","start","end","startInRadians","map","endInRadians","startLatitude","startLongitude","endLatitude","endLongitude","latitudeDelta","longitudeDelta","sin","cos","c","atan2","milesToKm","mile","buildPolyline","geojson","length","polyline","mileLength","euclideanLength","segments","i","mileDist","euclideanDist","push","distanceCovered","forEach","segment","index","mileDistance","percentCovered","accumulatedPercentCovered","getInterpolatedPoint","segmentPercentage","offset","offsetProportion","startLat","startLong","endLat","endLong","deltaX","abs","deltaY","offsetX","offsetY","binarySearcher","percent","min","max","mid","floor","prevAccumulatedPercent","percentRemaining","Polyline","line","getLengthInMiles","createLine","getDistanceBetweenPoints","getDistanceBetweenPointsKm"],"mappings":"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"}